<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://uniffle.apache.org/blog</id>
    <title>Apache Uniffle (Incubating) Blog</title>
    <updated>2023-07-21T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://uniffle.apache.org/blog"/>
    <subtitle>Apache Uniffle (Incubating) Blog</subtitle>
    <icon>https://uniffle.apache.org/img/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[Uniffle - New chapter for the shuffle in the cloud native era]]></title>
        <id>https://uniffle.apache.org/blog/2023/07/21/Uniffle - New chapter for the shuffle in the cloud native era</id>
        <link href="https://uniffle.apache.org/blog/2023/07/21/Uniffle - New chapter for the shuffle in the cloud native era"/>
        <updated>2023-07-21T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[<!--]]></summary>
        <content type="html"><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="background">Background<a href="#background" class="hash-link" aria-label="Direct link to Background" title="Direct link to Background">​</a></h2><p>Shuffle is the process in distributed computing frameworks used to redistribute data between upstream and downstream tasks. It is a crucial component within computing frameworks and directly impacts their performance and stability.
However, with the exploration of cloud-native architectures, traditional shuffle solutions have revealed various issues. </p><p>In a cloud-native architecture, with use of techniques such as the separation of storage and compute, mixed deployment.The computational nodes have relatively low disk volume, poor IO performance, and an imbalance between CPU and IO resources.
Additionally, computational nodes could be preempted by high-priority jobs due to mixed deployments.</p><p>In traditional Shuffle implementations, shuffle nodes tightly coupled with computational nodes. However, due to the different resource requirements for disk, memory and CPU between computational nodes and shuffle nodes, it is challenging to independently scale them based on their resource needs.
By separating the computational nodes from shuffle nodes, the computational node's state becomes more lightweight after offloading the Shuffle state to shuffle nodes, reducing the job recomputation when computational nodes are preempted. </p><p>Decoupling computational and Shuffle nodes also reduces the demand for disk specifications on computational nodes, enabling an increase in the number of accessible computational nodes.</p><p>In cloud-native architectures, large Shuffle jobs can exert significant pressure on local disk drives, leading to issues such as insufficient disk capacity on computational nodes and higher disk random IO, thus affecting the performance and stability of large Shuffle jobs.</p><p>The industry has explored various new Shuffle technologies, including Google's BigQuery, Baidu DCE Shuffle, Facebook's Cosco Shuffle, Uber Zeus Shuffle, Alibaba's Celeborn Shuffle, and many others.
Each system has made its own trade-offs based on different scenarios. Uniffle aims to create a fast, accurate, stable and cost-efficient cloud-native Remote Shuffle Service, considering performance, correctness, stability, and cost as its core aspects.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="architecture">Architecture<a href="#architecture" class="hash-link" aria-label="Direct link to Architecture" title="Direct link to Architecture">​</a></h2><p><img loading="lazy" alt="Architecture" src="/assets/images/architecture-19961714e3381cf27bf55e28bd212b00.png" width="1286" height="648" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="coordinator">Coordinator<a href="#coordinator" class="hash-link" aria-label="Direct link to Coordinator" title="Direct link to Coordinator">​</a></h3><p>The Coordinator is responsible for managing the entire cluster, and the Shuffle Server reports the cluster's load situation to the Coordinator through heartbeats. Based on the cluster's load, the Coordinator assigns suitable Shuffle Servers for jobs. To facilitate operations and maintenance, the Coordinator supports configuration deployment and provides a RESTFUL API for external access.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="shuffle-server">Shuffle Server<a href="#shuffle-server" class="hash-link" aria-label="Direct link to Shuffle Server" title="Direct link to Shuffle Server">​</a></h3><p>Shuffle Server is primarily responsible for receiving, aggregating  and writing shuffle data into storage. For shuffle data stored in local disks, Shuffle Server provides the ability to read the data.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="client">Client<a href="#client" class="hash-link" aria-label="Direct link to Client" title="Direct link to Client">​</a></h3><p>The Client is responsible for communicating with the Coordinator and Shuffle Server. It handles tasks such as requesting Shuffle Servers, sending heartbeats, and performing read and write operations on shuffle data. It provides an SDK for Spark, MapReduce and Tez to use.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="read--write-process">Read &amp; Write process<a href="#read--write-process" class="hash-link" aria-label="Direct link to Read &amp; Write process" title="Direct link to Read &amp; Write process">​</a></h2><p><img loading="lazy" alt="process" src="/assets/images/process-926f89bbddc4b91bcccbb0e3c019025c.png" width="1076" height="482" class="img_ev3q"></p><ol><li>The Driver obtains allocation information from the Coordinator.</li><li>The Driver registers Shuffle information with the Shuffle Server.</li><li>Based on the allocation information, the Executor sends Shuffle data to the Shuffle Server in the form of Blocks.</li><li>The Shuffle Server writes the data into storage.</li><li>After writing tasks completed, the Executor updates the result to the Driver.</li><li>The read task retrieves successful write task information from the Driver.</li><li>The read task retrieves Shuffle metadata (such as all blockIds) from the Shuffle Server.</li><li>Based on the storage model, the read task reads Shuffle data from the storage side.</li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="performance">Performance<a href="#performance" class="hash-link" aria-label="Direct link to Performance" title="Direct link to Performance">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1-hybrid-storage">1) Hybrid storage<a href="#1-hybrid-storage" class="hash-link" aria-label="Direct link to 1) Hybrid storage" title="Direct link to 1) Hybrid storage">​</a></h3><p>In our internal production environment, there are Partition data blocks at the KB level which account for more than 80% of the total. In order to effectively address the random IO issues caused by these small partitions, Uniffle incorporates the concept of in-memory Shuffle, taking reference from Google's Dremel. Additionally, considering that 80% of the data capacity in the our production environment is due to large partitions, Uniffle introduces disk and HDFS as storage media to address the data capacity problem. This forms a hybrid storage solution.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2-random-io-optimization">2) Random IO Optimization<a href="#2-random-io-optimization" class="hash-link" aria-label="Direct link to 2) Random IO Optimization" title="Direct link to 2) Random IO Optimization">​</a></h3><p><img loading="lazy" alt="random_io" src="/assets/images/io_random-93469fcb7b6d912b25abeb3ec2f9b48d.png" width="840" height="552" class="img_ev3q">
The essence of random IO is the existence of numerous small data block operations. In order to avoid these operations, Uniffle first aggregates multiple MapTasks' identical partitions in the memory of the Shuffle Server to generate larger partition data. When the Shuffle data in memory reaches the partition threshold or the overall threshold, it is written into local or remote storage.
<img loading="lazy" alt="io_sort" src="/assets/images/io_sort-4e4445257d6dfd93fcbd173db1ad15ea.png" width="692" height="384" class="img_ev3q">
When the overall threshold of memory reached, Uniffle sorted the partition data in memory based on their size. Uniffle write the larger partitions to the storage media first. Additionally, when the data in memory reach to a certain size, the writing of Shuffle data to the storage media is stopped, let some data stay in the memory to further reduce random IO on the disk.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="3-storage-media-selection-strategy">3) Storage media selection strategy<a href="#3-storage-media-selection-strategy" class="hash-link" aria-label="Direct link to 3) Storage media selection strategy" title="Direct link to 3) Storage media selection strategy">​</a></h3><p><img loading="lazy" alt="select" src="/assets/images/select-bbfd10c777e86778f62df639415151e3.png" width="1520" height="1072" class="img_ev3q">
For writing Shuffle data to local or remote storage, Uniffle has observed through testing that larger data block sizes result in better write performance for remote storage. When the data block size exceeds 64MB, the write performance to remote storage can reach 32MB/s. It's enough writing speed if we use multiple threads to write, comparing to the 100MB/s writing speed of HDD.Therefore, when writing data to storage media, Uniffle selects to write larger data blocks to remote storage based on their size, while smaller data blocks are written to local storage.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="4-write-concurrency">4) Write concurrency<a href="#4-write-concurrency" class="hash-link" aria-label="Direct link to 4) Write concurrency" title="Direct link to 4) Write concurrency">​</a></h3><p>For larger partitions, it is challenging to meet the performance requirements of writing to remote storage with a single thread. In HDFS, a file can only be written by one writer. To address this limitation, Uniffle allows multiple files to be mapped to a single partition for remote storage. Uniffle utilizes multi-threading to increase the writing performance of large partitions. However, it's important to note that a single partition occupying all remote storage threads can affect the writing performance of other partitions. Typically, there is a maximum limit on the number of concurrent write threads for a single partition. To avoid creating too many files, during the writing process, a partition will prioritize using already existing files. Only when all existing files are being written to, a new file will be created to store the data.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5-data-distribution">5) Data Distribution<a href="#5-data-distribution" class="hash-link" aria-label="Direct link to 5) Data Distribution" title="Direct link to 5) Data Distribution">​</a></h3><p><img loading="lazy" alt="aqe" src="/assets/images/aqe-6090c8ed1b91b4b4892a95c69e9a1fb5.png" width="1636" height="678" class="img_ev3q">
For computational engines like Spark AQE (Adaptive Query Execution), there are scenarios where a single task needs to read only a portion of a partition's data, as well as scenarios where multiple partitions need to be read. In the case of reading a portion of a partition's data, if the data is randomly distributed, it can result in a significant amount of read amplification. Performing data sorting and rewriting after the data is written can lead to considerable performance loss. Therefore, Uniffle adopts a solution of partial ordering to optimize the reading of partial data. For more detailed information, please refer to <!-- -->[3]<!-- -->.
<img loading="lazy" alt="get_results" src="/assets/images/get_results-71ce542dca970bff80b6d444dbf4081c.png" width="1436" height="478" class="img_ev3q">
In scenarios where multiple partitions need to be read, an optimization technique in Uniffle involves allocating the task of reading multiple partitions to a single ShuffleServer. This allows for the aggregation of Rpc (Remote Procedure Call) requests, which means that multiple Rpc requests can be sent to a single Shuffle Server. This approach helps to minimize network overhead and improve overall performance. For more detailed information, please refer to <!-- -->[4]<!-- -->.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="6-off-heap-memory-management">6) Off-heap memory management<a href="#6-off-heap-memory-management" class="hash-link" aria-label="Direct link to 6) Off-heap memory management" title="Direct link to 6) Off-heap memory management">​</a></h3><p>In the data communication process of Uniffle, Grpc is used, and there are multiple memory copying processes in the Grpc code implementation. Additionally, the Shuffle Server currently uses heap memory for management. When using an 80GB memory Shuffle Server in a production environment, it may experience a significant amount of garbage collection (GC), with individual GC pauses lasting approximately 22 seconds. To address this issue, Uniffle upgraded the JDK to version 11. On the data transmission side, Uniffle refer to the communication protocol of Spark Shuffle and adopted Netty for data transfer. It also utilized ByteBuf to manage off-heap memory more efficiently.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="7-columnar-shuffle-format">7) Columnar Shuffle Format<a href="#7-columnar-shuffle-format" class="hash-link" aria-label="Direct link to 7) Columnar Shuffle Format" title="Direct link to 7) Columnar Shuffle Format">​</a></h3><p>The Uniffle framework itself does not natively support columnar Shuffle. To leverage the columnar Shuffle capabilities, Uniffle integrates with Gluten, a columnar shuffle component. By integrating with Gluten, Uniffle is able to reuse the columnar Shuffle capabilities provided by Gluten. For more detailed information, please refer to <!-- -->[5]<!-- -->.
<img loading="lazy" alt="Gluten" src="/assets/images/gluten-cc81f323d5ee32b7e66bacb4c092cf03.png" width="1566" height="876" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="8-barrier-free">8) Barrier-Free<a href="#8-barrier-free" class="hash-link" aria-label="Direct link to 8) Barrier-Free" title="Direct link to 8) Barrier-Free">​</a></h3><p>For batch processing in distributed computing frameworks, the commonly used model is the Bulk Synchronous Parallel (BSP) model. In this model, downstream tasks started after all upstream tasks have completed. However, to reduce the impact of straggler nodes on job performance, some computing frameworks support a "slow start" mechanism to allow upstream and downstream tasks to run concurrently. On the other hand, for stream processing and OLAP engines, a pipeline model is used where upstream and downstream tasks can run simultaneously.</p><p>To cater to various computing frameworks, Uniffle employs a barrier-free design that allows upstream and downstream stages to run concurrently. The key to achieving this barrier-free execution lies in supporting efficient in-memory read/write operations and an effective index filtering mechanism. With this design, job execution does not require a request to the Shuffle Server for writing all data to storage media at the end of each stage. Additionally, since upstream and downstream stages run simultaneously, there may be cases where downstream readers only need to read incremental data. The index filtering mechanism effectively avoids reading redundant data.</p><p>Uniffle has designed both bitmap index filtering and file index filtering mechanisms to handle in-memory and storage media data respectively. This enables Uniffle to efficiently support barrier-free execution and improve performance by avoiding redundant data reads.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="performance-evaluation">Performance evaluation<a href="#performance-evaluation" class="hash-link" aria-label="Direct link to Performance evaluation" title="Direct link to Performance evaluation">​</a></h3><p>When using version 0.2 of Uniffle and conducting benchmarks, Uniffle's shuffle performance is similar to Spark's vanilla shuffle for small data volumes. However, for large data volumes, Uniffle's shuffle outperforms Spark's vanilla shuffle by up to 30%. The benchmark results can be found at the following link: <a href="https://github.com/apache/incubator-uniffle/blob/master/docs/benchmark.md" target="_blank" rel="noopener noreferrer">https://github.com/apache/incubator-uniffle/blob/master/docs/benchmark.md</a></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="correctness">Correctness<a href="#correctness" class="hash-link" aria-label="Direct link to Correctness" title="Direct link to Correctness">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="metadata-verification">Metadata Verification<a href="#metadata-verification" class="hash-link" aria-label="Direct link to Metadata Verification" title="Direct link to Metadata Verification">​</a></h3><p><img loading="lazy" alt="meta" src="/assets/images/metadata-b4e7588ef03930e4cfdec890e9324e2b.png" width="1496" height="596" class="img_ev3q">
Spark reports information about all completed tasks to the driver. In the first step of the reducer, the reducer retrieves a list of task unique identifiers from the driver. Blocks are the data sent from mappers to the shuffle server, and each block has a unique identifier. The data of a block is stored in memory, on local disk, or in HDFS. To ensure data integrity, Uniffle incorporates metadata verification. Uniffle designs index files for data files stored on local disks and in HDFS. The index file contains information such as the block ID, relative offset, data checksum, compressed length, uncompressed length, and task ID. Before reading a data file, Uniffle first reads the corresponding index file. To address duplicate read issues, Uniffle uses a bitmap to keep track of the already read block IDs. By checking the block ID, Uniffle can determine if a duplicate read exists.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="data-verification">Data Verification<a href="#data-verification" class="hash-link" aria-label="Direct link to Data Verification" title="Direct link to Data Verification">​</a></h3><p><img loading="lazy" alt="verify" src="/assets/images/data_read-31232b8cea5323ffee089e8667ad6226.png" width="1724" height="924" class="img_ev3q">
To address data corruption issues, Uniffle performs CRC (Cyclic Redundancy Check) verification on data blocks. When reading data, Uniffle recalculates the CRC and compares it with the CRC stored in the file to determine if the data is corrupted. This helps prevent reading incorrect data.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="stability">Stability<a href="#stability" class="hash-link" aria-label="Direct link to Stability" title="Direct link to Stability">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1-fallback-for-hybrid-storage">1) Fallback for Hybrid storage<a href="#1-fallback-for-hybrid-storage" class="hash-link" aria-label="Direct link to 1) Fallback for Hybrid storage" title="Direct link to 1) Fallback for Hybrid storage">​</a></h3><p><img loading="lazy" alt="hdfs" src="/assets/images/hdfs_fallback-8716b86a955947ccd6243028edd3e0b6.png" width="804" height="422" class="img_ev3q">
HDFS online clusters may experience some fluctuations in stability, which can result in failures to write data to HDFS during certain time periods. In order to minimize the impact caused by HDFS fluctuations, Uniff has designed a Fallback mechanism. When writing to HDFS fails, the data will be stored locally instead, reducing the impact on the job.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2-flow-control">2) Flow Control<a href="#2-flow-control" class="hash-link" aria-label="Direct link to 2) Flow Control" title="Direct link to 2) Flow Control">​</a></h3><p>Before sending a request, the job client will first request the memory resources corresponding to the data. If there is insufficient memory, the job will wait and stop sending data, thereby implementing flow control for the job.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="3-replication">3) Replication<a href="#3-replication" class="hash-link" aria-label="Direct link to 3) Replication" title="Direct link to 3) Replication">​</a></h3><p>Uniffle adopts the Quorum replica protocol, allowing jobs to configure the number of replicas for their data writes based on their own needs. This helps prevent stability issues caused by having only a single replica for the job.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="4-stage-recomputation">4) Stage Recomputation<a href="#4-stage-recomputation" class="hash-link" aria-label="Direct link to 4) Stage Recomputation" title="Direct link to 4) Stage Recomputation">​</a></h3><p>Currently, Spark supports recomputing the entire stage if there is a failure in reading from the Shuffle Server, helping the job recover and resume its execution.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5-quota-management">5) Quota Management<a href="#5-quota-management" class="hash-link" aria-label="Direct link to 5) Quota Management" title="Direct link to 5) Quota Management">​</a></h3><p>When a job reaches the user's quota limit, the Coordinator can make the job fallback to the vanilla Spark mode. This prevents from the situation that a single user's erroneous submission of numerous jobs.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="6-coordinator-ha">6) Coordinator HA<a href="#6-coordinator-ha" class="hash-link" aria-label="Direct link to 6) Coordinator HA" title="Direct link to 6) Coordinator HA">​</a></h3><p>Uniffle does not choose solutions like Zookeeper, Etcd, or Raft for high availability (HA) purposes, mainly considering the complexity introduced by these consensus protocol systems. For Uniffle, the Coordinator is stateless and does not persist any state. All state information is reported by the Shuffle Server through heartbeats, so there is no need to determine which node is the master. Deploying multiple Coordinator instances ensures high availability of the service.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="cost-effective">Cost Effective<a href="#cost-effective" class="hash-link" aria-label="Direct link to Cost Effective" title="Direct link to Cost Effective">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1-low-cost-remote-storage">1) Low-Cost Remote Storage<a href="#1-low-cost-remote-storage" class="hash-link" aria-label="Direct link to 1) Low-Cost Remote Storage" title="Direct link to 1) Low-Cost Remote Storage">​</a></h3><p>In general, for a relatively stable business, computational resources tend to remain stable while storage resources grow linearly. These storage resources store a large amount of cold data. Uniffle supports hybrid storage, which allows the utilization of these unused storage resources, thereby reducing the overall system cost.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2-automatic-scaling">2) Automatic Scaling<a href="#2-automatic-scaling" class="hash-link" aria-label="Direct link to 2) Automatic Scaling" title="Direct link to 2) Automatic Scaling">​</a></h3><p>Uniffle has developed a K8S Operator that implements scaling operations for stateful services using webhooks. By leveraging Horizontal Pod Autoscaler (HPA), automatic scaling can be achieved, further reducing system costs.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="community-engagement">Community Engagement<a href="#community-engagement" class="hash-link" aria-label="Direct link to Community Engagement" title="Direct link to Community Engagement">​</a></h2><p>Currently, Uniffle supports multiple computational frameworks such as Spark, MapReduce, and Tez.</p><p>Uniffle Spark has been adopted by companies like Tencent, Didi, iQiyi, SF Express, and Vipshop, handling PB-level data on a daily basis.</p><p>Uniffle MapReduce is employed in mixed deployment scenarios by companies like Bilibili and Zhihu</p><p>Uniffle Tez has been jointly developed by HuoLaLa, Beike, and Shein.</p><p>The development of many important features in the community has involved contributions from well-known Chinese internet companies.
For example, iQiyi has contributed support for accessing Kerberos HDFS clusters and has optimized the performance of Spark AQE on Uniffle.Didi has added support for multi-tenant job quotas. Netty data plane optimizations were jointly completed by Didi and Vipshop.The support for Gluten was contributed by Baidu and SF Express.</p><p>Currently, the community has more than 50 contributors, with over 600 commits, and has released four Apache versions. It is being used by dozens of companies. Additionally, teams and companies interested in contributing to Uniffle Flink can contact the Uniffle community at mailto:<a href="mailto:dev@uniffle.apache.org" target="_blank" rel="noopener noreferrer">dev@uniffle.apache.org</a>.</p><p>Currently, there are no companies participating in the community with deployment scenarios or development plans for Uniffle Flink. Your help in filling this gap in the community would be greatly appreciated. Uniffle's design incorporates a large number of mechanisms and strategies, and users are welcome to contribute strategies that suit their own scenarios.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="future-plans">Future Plans<a href="#future-plans" class="hash-link" aria-label="Direct link to Future Plans" title="Direct link to Future Plans">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="storage-optimization">Storage Optimization<a href="#storage-optimization" class="hash-link" aria-label="Direct link to Storage Optimization" title="Direct link to Storage Optimization">​</a></h3><ol><li>Integration with object storage to optimize system costs.</li><li>Merging index files and data files to further reduce IO overhead.</li><li>Support for heterogeneous storage resources such as SSD and HDD.</li><li>Support for sorting data by key.</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="computation-optimization">Computation Optimization<a href="#computation-optimization" class="hash-link" aria-label="Direct link to Computation Optimization" title="Direct link to Computation Optimization">​</a></h3><ol><li>Support for dynamic allocation of Shuffle Servers.</li><li>Partial support for Slow Start feature in some engines.</li><li>Continuous optimizations for Spark AQE.</li><li>Support for the Flink engine.</li><li>Asynchronous data reading support for compute engines.</li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="summary">Summary<a href="#summary" class="hash-link" aria-label="Direct link to Summary" title="Direct link to Summary">​</a></h2><p>Uniffle has been designed with a focus on performance, correctness, stability, and cost-effectiveness, making it a suitable Shuffle system for cloud-native architectures. We welcome everyone to contribute to the Uniffle project. The Uniffle project can be found at <a href="https://github.com/apache/incubator-uniffle" target="_blank" rel="noopener noreferrer">https://github.com/apache/incubator-uniffle</a>.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="reference">Reference<a href="#reference" class="hash-link" aria-label="Direct link to Reference" title="Direct link to Reference">​</a></h2><p>[1]<!-- --> <a href="https://cloud.tencent.com/developer/article/1903023" target="_blank" rel="noopener noreferrer">https://cloud.tencent.com/developer/article/1903023</a></p><p>[2]<!-- --> <a href="https://cloud.tencent.com/developer/article/1943179" target="_blank" rel="noopener noreferrer">https://cloud.tencent.com/developer/article/1943179</a></p><p>[3]<!-- --> <a href="https://github.com/apache/incubator-uniffle/pull/137" target="_blank" rel="noopener noreferrer">https://github.com/apache/incubator-uniffle/pull/137</a></p><p>[4]<!-- --> <a href="https://github.com/apache/incubator-uniffle/pull/307" target="_blank" rel="noopener noreferrer">https://github.com/apache/incubator-uniffle/pull/307</a></p><p>[5]<!-- --> <a href="https://github.com/apache/incubator-uniffle/pull/950" target="_blank" rel="noopener noreferrer">https://github.com/apache/incubator-uniffle/pull/950</a></p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2022 summary]]></title>
        <id>https://uniffle.apache.org/blog/2023/01/09/2022 summary</id>
        <link href="https://uniffle.apache.org/blog/2023/01/09/2022 summary"/>
        <updated>2023-01-09T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[<!--]]></summary>
        <content type="html"><![CDATA[<h1>Apache Uniffle (incubating) - 2022 summary</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="introduction">Introduction<a href="#introduction" class="hash-link" aria-label="Direct link to Introduction" title="Direct link to Introduction">​</a></h2><p>At the end of 2020,  Apache Uniffle (incubating)'s first line of code was written inside Tencent. It was open-sourced in November 2021, and then donated to the Apache Foundation in the mid-2022. Since its donation, it has attracted many developers from various companies. This article makes a brief summary of Apache Uniffle (incubating) in 2022.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="timeline">Timeline<a href="#timeline" class="hash-link" aria-label="Direct link to Timeline" title="Direct link to Timeline">​</a></h2><p>Apache Uniffle (Incubating) was accepted as an Apache incubator project on June 6, 2022. As of the end of December 2022 (current writing time: 2022.12.26), a total of 157 new issues have been created (76 of which have been closed or resolved), and new 272 PRs (of which 264 were merged or closed).</p><p>Apache Uniffle (incubating) has released two versions in 2022: 0.6.0 and 0.6.1. Among them:</p><ol><li>2022.10.27: Version 0.6.0 released</li><li>2022.11.30: Version 0.6.1 released</li></ol><p>Version 0.6.0 is the first version released after Uniffle entered the Apache incubator.  It features: </p><ol><li>Optimizes the Coordinator's allocation mechanism</li><li>Optimizes the scheduling strategy for <code>Shuffle Server</code></li><li>Optimizes performance and stability</li><li>Supports HDFS that requires Kerberos authentication</li><li>Supports the Uniffle K8S Operator, allowing it to be deployed and applied in a cloud-native environment.</li></ol><p>Version 0.6.1 is an important bug fix version after version 0.6.0. It mainly fixes the following problems:</p><ol><li>In the MR computing framework, when the number of reduce tasks exceeds 1024, the partition cannot be accessed</li><li>Concurrent registration of shuffle leads to failure to obtain shuffle results</li><li>Handle NPE in WriteBufferManager#addRecord</li><li>When there is a bad disk, there may be a memory leak
In addition to the above two versions, local order is introduced in the current master branch to cope with the data skew optimization of Spark AQE. Compared with the unoptimized version, the performance is improved by 3 times.</li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="community">Community<a href="#community" class="hash-link" aria-label="Direct link to Community" title="Direct link to Community">​</a></h2><p>Apache Uniffle (incubating) has added 22 contributors since entering the incubator, with a total of 33 contributors. Contributors come from Tencent, iQiyi, Ebay, Didi, SF Express, Baidu, ByteDance, JD.com, Bilibili, Databricks And other Internet companies. Among the 22 new contributors, Apache Uniffle (incubating) PMC voted to add 2 new committers according to their contribution. The new recruited committers are expected to make continuous contributions to Apache Uniffle (incubating) and we are planing to added more committers in 2023.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="company-usage">Company Usage<a href="#company-usage" class="hash-link" aria-label="Direct link to Company Usage" title="Direct link to Company Usage">​</a></h2><p>According to the online/offline communication with contributors and users, Apache Uniffle (incubating) is currently in production and used in companies such as Tencent, iQiyi, Didi, SF Express, VIPShop, Bilibili, etc. The amount of shuffle data processed by Uniffle of many companies exceeds PBs per day, and tens of thousands of apps are running. In addition to solving the stability and scalability problems of native Spark shuffle, it also improves the overall resource utilization.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="project-plans">Project Plans<a href="#project-plans" class="hash-link" aria-label="Direct link to Project Plans" title="Direct link to Project Plans">​</a></h2><p>In 2023, Apache Uniffle (incubating) will continue to provide an efficient and pervasive Shuffle Service. Currently, the following work is on the planning list:</p><ol><li>A more complete compute engine ecology<ul><li>Support Tez computing framework</li><li>Support Flink computing framework</li></ul></li><li>Support more storage media, especially distributed storages:<ul><li>Efficient support for object storage</li><li>HDD, SSD and other local hybrid storage support</li></ul></li><li>Performance optimization:<ul><li>Replace gRPC with Netty</li><li>Off-heap memory management, application of zero-copy technology, reducing data copying</li></ul></li><li>More enterprise-level features:<ul><li>Multi-tenant isolation related function development</li><li>Improved stability and reliability</li></ul></li></ol>]]></content>
    </entry>
</feed>